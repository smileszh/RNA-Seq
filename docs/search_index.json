[["index.html", "RNA-Seq 前言", " RNA-Seq 苏总华 2025-01-06 前言 RNA-Seq Pipeline 我不是代码的创作者，我只是代码的搬运工。 "],["数据预处理.html", "第 1 章 数据预处理 1.1 物种 1.2 Counts 数据预处理 1.3 构建样本分组信息 1.4 构建组间比较信息 1.5 保存数据", " 第 1 章 数据预处理 1.1 物种 species = &#39;human&#39; 1.2 Counts 数据预处理 # 加载数据 data&lt;-data.table::fread(&quot;raw_counts.txt&quot;, data.table = F) head(data, 3) ## ID a-1 a-2 a-3 b-1 b-2 b-3 c-1 c-2 c-3 d-1 d-2 d-3 ## 1 ENSG00000282222 0 0 0 0 0 0 0 0 0 0 0 0 ## 2 ENSG00000282221 2 0 0 0 0 0 0 0 0 0 0 0 ## 3 ENSG00000308368 4 3 0 2 0 1 6 3 9 5 4 4 dim(data) ## [1] 80170 13 data &lt;- data[!duplicated(data$ID),] # ENSEMBLE ID to SYMBOL library(AnnoProbe) ids &lt;- annoGene(data$ID, ID_type = &#39;ENSEMBL&#39;,species = species) ids=ids[!duplicated(ids$ENSEMBL),] # 重复ID直接删除 ids=ids[!duplicated(ids$SYMBOL),] # 重复ID直接删除 data = data[data$ID %in% ids$ENSEMBL,] pos = match(data$ID, ids$ENSEMBL) data = cbind(data, ids[pos, ]) rownames(data) = NULL 1.3 构建样本分组信息 library(stringr) library(tidyverse) count &lt;- data %&gt;% tibble::column_to_rownames(var = &quot;SYMBOL&quot;) %&gt;% select(-c(&quot;ID&quot;, &quot;biotypes&quot;, &quot;ENSEMBL&quot;, &quot;chr&quot;, &quot;start&quot;, &quot;end&quot;)) ## 也可以手动创建一个分组信息 group_list &lt;- str_split(colnames(count),&#39;[-_]&#39;,simplify = T)[,1] group &lt;- data.frame(sample = colnames(count), group = group_list) table(group) ## group ## sample a b c d ## a-1 1 0 0 0 ## a-2 1 0 0 0 ## a-3 1 0 0 0 ## b-1 0 1 0 0 ## b-2 0 1 0 0 ## b-3 0 1 0 0 ## c-1 0 0 1 0 ## c-2 0 0 1 0 ## c-3 0 0 1 0 ## d-1 0 0 0 1 ## d-2 0 0 0 1 ## d-3 0 0 0 1 1.4 构建组间比较信息 group_compare &lt;- list( a_vs_b = c(&quot;a&quot;, &quot;b&quot;) %&gt;% factor(levels = c(&quot;a&quot;, &quot;b&quot;)), c_vs_d = c(&quot;c&quot;, &quot;d&quot;) %&gt;% factor(levels = c(&quot;c&quot;, &quot;d&quot;)), a_vs_c = c(&quot;a&quot;, &quot;c&quot;) %&gt;% factor(levels = c(&quot;a&quot;, &quot;c&quot;)) ) 1.5 保存数据 dir.create(&quot;Expression_Annotation/1_Expression_result&quot;, recursive = T) library(writexl) write_xlsx(data, &quot;Expression_Annotation/1_Expression_result/All_gene_counts.xlsx&quot;) dir.create(&quot;Rdata&quot;, recursive = T) save(species, count, data, group, group_compare, file = &quot;Rdata/data.RData&quot;) "],["基因-id-注释.html", "第 2 章 基因 ID 注释", " 第 2 章 基因 ID 注释 # 安装并加载必要的包 library(biomaRt) library(org.Hs.eg.db) library(org.Mm.eg.db) get_annotations &lt;- function(gene_list, species = &quot;human&quot;) { # 设置物种相关信息 if (species == &quot;human&quot;) { ensembl_dataset &lt;- &quot;hsapiens_gene_ensembl&quot; org_db &lt;- &quot;org.Hs.eg.db&quot; kegg_prefix &lt;- &quot;hsa&quot; } else if (species == &quot;mouse&quot;) { ensembl_dataset &lt;- &quot;mmusculus_gene_ensembl&quot; org_db &lt;- &quot;org.Mm.eg.db&quot; kegg_prefix &lt;- &quot;mmu&quot; } else { stop(&quot;Unsupported species. Please use &#39;human&#39; or &#39;mouse&#39;.&quot;) } # 使用biomaRt获取基因基本注释信息 ensembl &lt;- useMart(&quot;ensembl&quot;, dataset = ensembl_dataset) attributes &lt;- c( &#39;hgnc_symbol&#39;, &#39;ensembl_gene_id&#39;, &#39;entrezgene_id&#39;, &#39;description&#39; ) gene_annotations &lt;- getBM(attributes = attributes, filters = &#39;hgnc_symbol&#39;, values = gene_list, mart = ensembl) } # 定义基因列表 gene_list &lt;- data$SYMBOL # 获取注释信息 annotations &lt;- get_annotations(gene_list, species) # 保存注释结果 dir.create(&quot;Expression_Annotation/1_Expression_result/&quot;, recursive = T) writexl::write_xlsx(annotations, &quot;Expression_Annotation/1_Expression_result/All_gene_annotations.xlsx&quot;) "],["基因表达定量.html", "第 3 章 基因表达定量 3.1 基因表达定量 3.2 基因表达分布 3.3 生物学重复相关性分析", " 第 3 章 基因表达定量 3.1 基因表达定量 3.1.1 FPKM / RPKM 转录本的片段数量受测序数据量（或比对到的reads数量）、转录本长度、转录本表达水平的影响。为了更准确地揭示每个转录本的表达水平，需要通过其转录本的长度对比对到的reads数量进行标准化。 FPKM（每千碱基转录本每百万比对片段数）被应用于测量基因或转录本的表达水平。FPKM的计算公式如下所示。 \\[ \\text{FPKM} = \\frac{\\text{number of fragments}}{\\text{length of transcript (in kilobases)} \\times \\text{total number of mapped reads (in millions)}} \\] # 下载并加载必要的包 library(tidyverse) library(writexl) counts &lt;- count %&gt;% as.matrix() # 计算每个样本中的总的测序读数 total_count &lt;- colSums(count) # 计算基因长度（以kb为单位） gene_positions &lt;- data %&gt;% select(SYMBOL, start, end) %&gt;% distinct() gene_positions$Length_kb &lt;- (gene_positions$end - gene_positions$start + 1) / 1000 # 创建 DGEList 对象 library(edgeR) dge &lt;- DGEList(counts = count) # 计算FPKM # edgeR 使用 RPKM 函数来计算 RPKM 和 FPKM # 传入基因长度（以kb为单位）和总的测序读数 fpkm &lt;- rpkm(dge, gene.length = gene_positions$Length_kb * 1000) %&gt;% as.data.frame() ## 保存结果 dir.create(&quot;Expression_Annotation/1_Expression_result&quot;, recursive = T) All_gene_fpkm &lt;- fpkm %&gt;% rename_with(~ paste0(.x, &quot;.FPKM&quot;)) %&gt;% rownames_to_column(var = &quot;SYMBOL&quot;) %&gt;% left_join(data %&gt;% select(ID, SYMBOL, everything()), by = &quot;SYMBOL&quot;) writexl::write_xlsx(All_gene_fpkm, &quot;Expression_Annotation/1_Expression_result/All_gene_fpkm.xlsx&quot;) save(species, count, fpkm, data, group, group_compare, file = &quot;Rdata/data.RData&quot;) 3.2 基因表达分布 # 下载并加载必要的包 library(tidyverse) library(reshape2) fpkm_df &lt;- fpkm[rowSums(fpkm &gt;1) &gt; 1,] fpkm_long &lt;- log10(fpkm_df+1) %&gt;% melt(variable.name = &quot;variable&quot;, value.name = &quot;value&quot;) 3.2.1 箱线图 ALL_box &lt;- ggplot(fpkm_long, aes(x = variable, y = value, fill = variable)) + geom_boxplot(outlier.color = &quot;black&quot;, outlier.shape = 16, outlier.size = 2) + scale_fill_brewer(palette = &quot;Set3&quot;) + theme_bw() + theme( axis.text.x = element_text(size=13, angle = 45, vjust = 1, hjust=1, color = &quot;black&quot;), axis.text.y = element_text(size=13, color = &quot;black&quot;), axis.title.x = element_text(size = 14, face = &quot;bold&quot;), axis.title.y = element_text(size = 14, face = &quot;bold&quot;), plot.title = element_text(hjust = 0.5, size = 16, face = &quot;bold&quot;), legend.position = &quot;none&quot;, panel.grid.major = element_blank(), # 去掉主要网格线 panel.grid.minor = element_blank() # 去掉次要网格线 ) + labs(x = &quot;Samples&quot;, y = &quot;log2(FPKM+1)&quot;) dir.create(&quot;Expression_Annotation/2_Expression_distribution&quot;) ggsave(plot = ALL_box, filename = &quot;./Expression_Annotation/2_Expression_distribution/all.fpkm_box.pdf&quot;, width = 7, height = 4) 3.2.2 密度图 ALL_density &lt;- ggplot(fpkm_long) + geom_density(aes(x = value, fill = variable), alpha = 0.6) + scale_fill_brewer(palette = &quot;Set3&quot;) + # 使用颜色调色板 theme_bw() + # 使用简洁主题 theme( axis.title.x = element_text(size = 14, face = &quot;bold&quot;), axis.title.y = element_text(size = 14, face = &quot;bold&quot;), plot.title = element_text(hjust = 0.5, size = 16, face = &quot;bold&quot;), # 标题居中且加粗 axis.text = element_text(size = 12), # 轴文字字体大小 legend.position = &quot;right&quot;, # 图例位置 legend.title = element_text(size = 14), # 图例标题字体大小 legend.text = element_text(size = 12), # 图例文字字体大小 panel.grid.major = element_blank(), # 去掉主要网格线 panel.grid.minor = element_blank()) + # 去掉次要网格线 scale_x_continuous(limits = c(-1, NA)) + # 设置X轴最小值为-5，最大值自动 labs(x = &quot;log2(FPKM+1)&quot;, y = &quot;density&quot;, fill = &quot;Sample&quot;) # 修改图例标题 dir.create(&quot;Expression_Annotation/2_Expression_distribution&quot;) ggsave(plot = ALL_density, filename = &quot;./Expression_Annotation/2_Expression_distribution/all.fpkm_density.pdf&quot;, width = 6, height = 4) # 获取样本名列表 sample_names &lt;- unique(fpkm_long$variable) # 循环生成每个样本的密度图并保存 for (sample in sample_names) { # 过滤数据，仅保留当前样本的数据 sample_data &lt;- fpkm_long[fpkm_long$variable == sample, ] # 生成密度图 sample_density &lt;- ggplot(sample_data) + geom_density(aes(x = value, fill = variable), alpha = 0.6) + scale_fill_brewer(palette = &quot;Set3&quot;) + # 使用颜色调色板 theme_bw() + # 使用简洁主题 theme( axis.title.x = element_text(size = 14, face = &quot;bold&quot;), axis.title.y = element_text(size = 14, face = &quot;bold&quot;), plot.title = element_text(hjust = 0.5, size = 16, face = &quot;bold&quot;), # 标题居中且加粗 axis.text = element_text(size = 12), # 轴文字字体大小 legend.position = &quot;right&quot;, # 图例位置 legend.title = element_text(size = 14), # 图例标题字体大小 legend.text = element_text(size = 12), # 图例文字字体大小 panel.grid.major = element_blank(), # 去掉主要网格线 panel.grid.minor = element_blank()) + # 去掉次要网格线 scale_x_continuous(limits = c(-1, NA)) + # 设置X轴最小值为-5，最大值自动 labs(title = paste(&quot;Density Plot of&quot;, sample), x = &quot;log2(FPKM+1)&quot;, y = &quot;density&quot;, fill = &quot;Sample&quot;) # 修改图例标题 # 保存密度图 ggsave(plot = sample_density, filename = paste0(&quot;./Expression_Annotation/2_Expression_distribution/&quot;, sample, &quot;_fpkm_density.pdf&quot;), width = 6, height = 4) } save(species, count, fpkm, fpkm_long, data, group, group_compare, file = &quot;Rdata/data.Rdata&quot;) 3.3 生物学重复相关性分析 library(tidyverse) 3.3.1 样本间相关性点图 fpkm_df &lt;- fpkm[rowSums(fpkm &gt;1) &gt; 1,] fpkm_df &lt;- log10(fpkm_df+1) dir.create(&quot;Expression_Annotation/3_Sample_correlation/&quot;, recursive = T) # 获取样本名列表 sample_names &lt;- colnames(fpkm_df) # 循环生成每对样本的散点图并保存 for (i in 1:(length(sample_names) - 1)) { for (j in (i + 1):length(sample_names)) { sample1 &lt;- sample_names[i] sample2 &lt;- sample_names[j] # 提取两个样本的数据 sample_data &lt;- data.frame(x = fpkm_df[[sample1]], y = fpkm_df[[sample2]]) # 计算相关性 correlation &lt;- cor(sample_data$x, sample_data$y) # 生成散点图 scatter_plot &lt;- ggplot(sample_data, aes(x = x, y = y)) + geom_point(alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;blue&quot;) + # 添加线性拟合曲线 theme_bw() + # 使用简洁主题 theme( axis.title.x = element_text(size = 14, face = &quot;bold&quot;), axis.title.y = element_text(size = 14, face = &quot;bold&quot;), plot.title = element_text(hjust = 0.5, size = 16, face = &quot;bold&quot;), # 标题居中且加粗 axis.text = element_text(size = 12), # 轴文字字体大小 panel.grid.major = element_blank(), # 去掉主要网格线 panel.grid.minor = element_blank() # 去掉次要网格线 ) + labs(title = paste(&quot;Scatter Plot of&quot;, sample1, &quot;vs&quot;, sample2), x = paste(&quot;log2(FPKM+1) of&quot;, sample1), y = paste(&quot;log2(FPKM+1) of&quot;, sample2)) + annotate(&quot;text&quot;, x = min(sample_data$x, na.rm = TRUE), y = max(sample_data$y, na.rm = TRUE), label = paste(&quot;Correlation:&quot;, round(correlation, 2)), hjust = -0.2, vjust = 1.1, size = 5, color = &quot;black&quot;, fontface = &quot;bold&quot;) # 显示相关性值 # 保存散点图 ggsave(plot = scatter_plot, filename = paste0(&quot;./Expression_Annotation/3_Sample_correlation/&quot;, sample1, &quot;_vs_&quot;, sample2, &quot;_cor.pdf&quot;), width = 6, height = 6) } } 3.3.2 样本间相关性热图 # 安装并加载必要的包 library(pheatmap) # 计算样本间的相关性矩阵 correlation_matrix &lt;- cor(fpkm_df) # 生成相关性热图 library(RColorBrewer) All_phe &lt;- pheatmap(correlation_matrix, cluster_rows = TRUE, cluster_cols = TRUE, display_numbers = TRUE, # 显示相关性数值 number_format = &quot;%.2f&quot;, # 数值格式为小数点后两位 fontsize_number = 10, # 数值字体大小 main = &quot;Sample Correlation Heatmap&quot;, # 图标题 fontsize = 12, # 整体字体大小 fontsize_row = 10, # 行字体大小 fontsize_col = 10, # 列字体大小 border_color = NA, # 不显示边框 cellwidth = 30, # 单元格宽度 cellheight = 30, # 单元格高度 legend_breaks = seq(-1, 1, by = 0.2), # 图例刻度 legend_labels = seq(-1, 1, by = 0.2)) # 图例标签 dir.create(&quot;Expression_Annotation/3_Sample_correlation/&quot;, recursive = T) ggsave(plot = All_phe, filename = &quot;./Expression_Annotation/3_Sample_correlation/sample_cluster.pdf&quot;, width = 7, height = 7) 3.3.3 样本 PCA # 安装并加载必要的包 library(FactoMineR) library(factoextra) # 进行PCA分析 pca_result &lt;- PCA(t(fpkm_df), graph = FALSE) # 分组组信息 groups &lt;- factor(group$group) # 绘制PCA图 All_PCA &lt;- fviz_pca_ind(pca_result, geom.ind = &quot;point&quot;, #c( &quot;point&quot;, &quot;text&quot; ) col.ind = groups, addEllipses = T, ellipse.level = 0.95, repel = T, legend.title = &quot;Groups&quot; ) + ggtitle(&quot;PCA Plot with Groups&quot;) + theme_bw()+ theme(plot.title = element_text(size=12,hjust = 0.5) ) dir.create(&quot;Expression_Annotation/4_PCA/&quot;, recursive = T) ggsave(plot = All_PCA, filename = &quot;./Expression_Annotation/4_PCA/All_sample_PCA.pdf&quot;, width = 5, height = 5) # 绘制各组的PCA图 for (group_name in names(group_compare)) { selected_groups &lt;- group_compare[[group_name]] selected_samples &lt;- which(groups %in% selected_groups) selected_data &lt;- fpkm_df[, selected_samples] selected_pca &lt;- PCA(t(selected_data), graph = FALSE) selected_labels &lt;- groups[selected_samples] pca_plot &lt;- fviz_pca_ind(selected_pca, geom.ind = &quot;point&quot;, col.ind = selected_labels, addEllipses = TRUE, ellipse.level = 0.95, repel = TRUE, legend.title = &quot;Groups&quot; ) + ggtitle(paste(&quot;PCA Plot of&quot;, group_name)) + theme_bw() + theme(plot.title = element_text(size = 12, hjust = 0.5)) ggsave(plot = pca_plot, filename = paste0(&quot;./Expression_Annotation/4_PCA/&quot;, group_name, &quot;_PCA.pdf&quot;), width = 5, height = 4) } "],["差异表达分析.html", "第 4 章 差异表达分析 4.1 差异表达分析 4.2 差异表达基因筛选 4.3 差异基因可视化", " 第 4 章 差异表达分析 4.1 差异表达分析 4.1.1 DESeq2 # 安装加载必要的包 library(DESeq2) library(tidyverse) # 定义一个函数来进行 DESeq2 差异基因表达分析 run_deseq2 &lt;- function(count, group_df, group1, group2) { samples_group1 &lt;- group_df %&gt;% filter(group == group1) %&gt;% pull(sample) samples_group2 &lt;- group_df %&gt;% filter(group == group2) %&gt;% pull(sample) selected_samples &lt;- c(samples_group1, samples_group2) selected_counts &lt;- count[, selected_samples, drop = FALSE] selected_group &lt;- group_df %&gt;% filter(sample %in% selected_samples) # 创建 DESeq2 数据集 dds &lt;- DESeqDataSetFromMatrix(countData = selected_counts, colData = selected_group, design = ~ group) # 去除低表达基因 keep &lt;- rowSums(counts(dds)) &gt; 3 # 或者更严格筛选至少3个样本中计数大于或等于10的基因 # keep &lt;- rowSums(counts(dds) &gt;= 10) &gt;= 3 dds &lt;- dds[keep, ] # 运行 DESeq2 dds &lt;- DESeq(dds) # 获取结果 res &lt;- results(dds) %&gt;% as.data.frame() %&gt;% rownames_to_column(var = &quot;SYMBOL&quot;) # 得到标准化后的count normed = counts(dds, normalized=TRUE) %&gt;% round(1) # 整理结果 ## 创建 foldChange 列. res$foldChange = 2 ^ res$log2FoldChange ## 创建 FDR 列，原因[在此](https://www.biostars.org/p/462897/). res = dplyr::rename(res, FDR=padj) res$FDR[is.na(res$FDR)] &lt;- 1 ## 创建 padj 列. res$padj = p.adjust(res$pvalue, method=&quot;hochberg&quot;) ## 合并结果和标准化后的 count total &lt;- bind_cols(res, normed) %&gt;% arrange(FDR) # 创建其他想呈现的信息 ## 计算排序表的错误发现计数。 total$falsePos = 1:nrow(total) * total$FDR ## 创建各族均值 total$baseMeanA = 1 total$baseMeanB = 1 total$baseMeanA = rowMeans(total[, samples_group1]) total$baseMeanB = rowMeans(total[, samples_group2]) # 整理结果，美化输出 # total$foldChange = round(total$foldChange, 3) # total$log2FoldChange = round(total$log2FoldChange, 1) # total$baseMean = round(total$baseMean, 1) # total$baseMeanA = round(total$baseMeanA, 1) # total$baseMeanB = round(total$baseMeanB, 1) # total$lfcSE = round(total$lfcSE, 2) # total$stat = round(total$stat, 2) # total$FDR = round(total$FDR, 4) # total$falsePos = round(total$falsePos, 0) new_cols = c( &quot;SYMBOL&quot;,&quot;baseMean&quot;,&quot;baseMeanA&quot;,&quot;baseMeanB&quot;, &quot;foldChange&quot;, &quot;log2FoldChange&quot;, &quot;lfcSE&quot;,&quot;stat&quot;,&quot;pvalue&quot;,&quot;padj&quot;, &quot;FDR&quot;,&quot;falsePos&quot;, samples_group1, samples_group2) total = total[, new_cols] return(total) } # 进行两两比对并存储结果 dir.create(&quot;DEG_Analysis/1_DEG_stat/DESeq2&quot;, recursive = T) comparison_results_DESeq2 &lt;- lapply(names(group_compare), function(comp_name) { # 获取因子的水平 # comp_name &lt;- &quot;a_vs_b&quot; groups &lt;- levels(group_compare[[comp_name]]) group1 &lt;- groups[1] group2 &lt;- groups[2] # 打印调试信息 print(paste(&quot;Comparing&quot;, group1, &quot;vs&quot;, group2)) print(head(group)) # 运行 DESeq2 result &lt;- run_deseq2(count, group, group1, group2) # 保存结果 ## 定义结果文件名 result_file &lt;- paste0(comp_name, &quot;_DEG_DESeq2.csv&quot;) ## 将结果保存为 CSV 文件 write.csv(result, paste0(&quot;DEG_Analysis/1_DEG_stat/DESeq2/&quot;, result_file) , row.names = FALSE) return(result) }) ## [1] &quot;Comparing a vs b&quot; ## sample group ## 1 a-1 a ## 2 a-2 a ## 3 a-3 a ## 4 b-1 b ## 5 b-2 b ## 6 b-3 b ## [1] &quot;Comparing c vs d&quot; ## sample group ## 1 a-1 a ## 2 a-2 a ## 3 a-3 a ## 4 b-1 b ## 5 b-2 b ## 6 b-3 b ## [1] &quot;Comparing a vs c&quot; ## sample group ## 1 a-1 a ## 2 a-2 a ## 3 a-3 a ## 4 b-1 b ## 5 b-2 b ## 6 b-3 b names(comparison_results_DESeq2) &lt;- names(group_compare) save(comparison_results_DESeq2, file = &quot;Rdata/comparison_results_DESeq2.Rdata&quot;) 4.1.2 edgeR # 安装加载必要的包 library(edgeR) ## Loading required package: limma library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.4 ✔ readr 2.1.5 ## ✔ forcats 1.0.0 ✔ stringr 1.5.1 ## ✔ ggplot2 3.5.1 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.4 ✔ tidyr 1.3.1 ## ✔ purrr 1.0.2 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors # 定义一个函数来进行 edgeR 差异基因表达分析 run_edger &lt;- function(count, group_df, group1, group2) { samples_group1 &lt;- group_df %&gt;% filter(group == group1) %&gt;% pull(sample) samples_group2 &lt;- group_df %&gt;% filter(group == group2) %&gt;% pull(sample) selected_samples &lt;- c(samples_group1, samples_group2) selected_counts &lt;- count[, selected_samples, drop = FALSE] selected_group &lt;- group_df %&gt;% filter(sample %in% selected_samples) # 创建 DGEList 对象 group &lt;- factor(selected_group$group) deg &lt;- DGEList(counts = selected_counts, group = group) # 过滤低表达基因 keep &lt;- filterByExpr(deg) deg &lt;- deg[keep, , keep.lib.sizes = FALSE] # 规范化 deg &lt;- calcNormFactors(deg) # 设计矩阵 design &lt;- model.matrix(~ group) # 估计离散度 dge &lt;- estimateDisp(deg, design) # 进行广义线性模型拟合 fit &lt;- glmFit(dge, design) # 进行差异表达检验 qlf &lt;- glmLRT(fit, coef = 2) # 获取结果 etp = topTags(qlf, n=Inf) ## 获取数据 scale scale = dge$samples$lib.size * dge$samples$norm.factors ## 获取标准化 counts normed = round(t(t(selected_counts)/scale) * mean(scale)) ## 获取差异分析结果 dat = etp$table %&gt;% as.data.frame() %&gt;% rownames_to_column(var = &quot;SYMBOL&quot;) row.names(dat) = dat[,1] # 整理结果 ## Create column placeholders. dat$baseMean = 1 dat$baseMeanA = 1 dat$baseMeanB = 1 dat$foldChange = 2 ^ dat$logFC dat$log2FoldChange=dat$logFC dat$pvalue = dat$PValue dat$falsePos = 1 # Compute the adjusted p-value dat$padj = p.adjust(dat$pvalue, method=&quot;hochberg&quot;) # Create a merged output that contains the normalized counts. total &lt;- merge(dat, normed, by=&#39;row.names&#39;) # Get rid of extra column it gained total = total[, 2:ncol(total)] # Sort again by P-value. total = arrange(total, pvalue) # Compute the false discovery counts on the sorted table. total$falsePos = 1:nrow(total) * total$FDR # Create the individual baseMean columns. total$baseMeanA = rowMeans(total[, samples_group1]) total$baseMeanB = rowMeans(total[, samples_group2]) total$baseMean = total$baseMeanA + total$baseMeanB # Round the numbers to make them look better # total$foldChange = round(total$foldChange, 3) # total$FDR = round(total$FDR, 4) # total$padj = round(total$padj, 4) # total$logCPM = round(total$logCPM, 1) # total$log2FoldChange = round(total$log2FoldChange, 1) # total$baseMean = round(total$baseMean, 1) # total$baseMeanA = round(total$baseMeanA, 1) # total$baseMeanB = round(total$baseMeanB, 1) # total$falsePos = round(total$falsePos, 0) # Reorganize columns names to make more sense. new_cols = c( &quot;SYMBOL&quot;,&quot;baseMean&quot;,&quot;baseMeanA&quot;,&quot;baseMeanB&quot;, &quot;logCPM&quot;,&quot;foldChange&quot;, &quot;log2FoldChange&quot;, &quot;pvalue&quot;,&quot;padj&quot;, &quot;FDR&quot;,&quot;falsePos&quot;, samples_group1, samples_group2) total = total[, new_cols] # Reformat these columns as string. total$padj = formatC(total$padj, format = &quot;e&quot;, digits = 1) total$pvalue = formatC(total$pvalue, format = &quot;e&quot;, digits = 1) return(total) } # 进行两两比对并存储结果 dir.create(&quot;DEG_Analysis/1_DEG_stat/edgeR&quot;, recursive = TRUE) ## Warning in dir.create(&quot;DEG_Analysis/1_DEG_stat/edgeR&quot;, recursive = TRUE): ## &#39;DEG_Analysis/1_DEG_stat/edgeR&#39; already exists comparison_results_edgeR &lt;- lapply(names(group_compare), function(comp_name) { # 获取因子的水平 groups &lt;- levels(group_compare[[comp_name]]) group1 &lt;- groups[1] group2 &lt;- groups[2] # 打印调试信息 print(paste(&quot;Comparing&quot;, group1, &quot;vs&quot;, group2)) print(head(group)) # 运行 edgeR result &lt;- run_edger(count, group, group1, group2) # 保存结果 result_file &lt;- paste0(comp_name, &quot;_DEG_edgeR.csv&quot;) write.csv(result, paste0(&quot;DEG_Analysis/1_DEG_stat/edgeR/&quot;, result_file), row.names = FALSE) return(result) }) ## [1] &quot;Comparing a vs b&quot; ## sample group ## 1 a-1 a ## 2 a-2 a ## 3 a-3 a ## 4 b-1 b ## 5 b-2 b ## 6 b-3 b ## [1] &quot;Comparing c vs d&quot; ## sample group ## 1 a-1 a ## 2 a-2 a ## 3 a-3 a ## 4 b-1 b ## 5 b-2 b ## 6 b-3 b ## [1] &quot;Comparing a vs c&quot; ## sample group ## 1 a-1 a ## 2 a-2 a ## 3 a-3 a ## 4 b-1 b ## 5 b-2 b ## 6 b-3 b names(comparison_results_edgeR) &lt;- names(group_compare) save(comparison_results_edgeR, file = &quot;Rdata/comparison_results_edgeR.Rdata&quot;) 4.2 差异表达基因筛选 load(&quot;Rdata/comparison_results_DESeq2.Rdata&quot;) load(&quot;Rdata/comparison_results_edgeR.Rdata&quot;) # 可以自定义设定筛选差异基因的参数 FDR_cutoff &lt;- 0.05 log2FC_cutoff &lt;- 1 # 加载必要的包 library(tidyverse) # 定义筛选差异基因的函数 filter_DEGs &lt;- function(df, FDR_cutoff = 0.05, log2FC_cutoff = 1) { df &lt;- df %&gt;% mutate(regulated = case_when( FDR &lt; FDR_cutoff &amp; log2FoldChange &gt; log2FC_cutoff ~ &quot;up&quot;, FDR &lt; FDR_cutoff &amp; log2FoldChange &lt; -log2FC_cutoff ~ &quot;down&quot;, TRUE ~ &quot;normal&quot; )) return(df) } # 对列表中的每个数据框进行处理 cr_DESeq2 &lt;- setNames(lapply(comparison_results_DESeq2, filter_DEGs), names(comparison_results_DESeq2)) cr_edgeR &lt;- setNames(lapply(comparison_results_edgeR, filter_DEGs), names(comparison_results_edgeR)) # 导出处理后的数据框 for (i in names(cr_DESeq2)) { write.csv(cr_DESeq2[[i]], paste0(&quot;DEG_Analysis/1_DEG_stat/DESeq2/&quot;, i, &quot;_regulated_DESeq2.csv&quot;), row.names = FALSE) } for (i in names(cr_edgeR)) { write.csv(cr_edgeR[[i]], paste0(&quot;DEG_Analysis/1_DEG_stat/edgeR/&quot;, i, &quot;_regulated_edgeR.csv&quot;), row.names = FALSE) } save(cr_DESeq2, cr_edgeR, file = &quot;Rdata/Regulated_DEG.Rdata&quot;) 4.3 差异基因可视化 4.3.1 火山图 # 加载必要的包 library(tidyverse) library(ggrepel) # 定义画图函数 vol &lt;- function(data){ # 统计上下调基因的数量 regulated_counts &lt;- table(data$regulated) up_count &lt;- regulated_counts[&quot;up&quot;] down_count &lt;- regulated_counts[&quot;down&quot;] # 画图 p &lt;- ggplot(data, aes(x = log2FoldChange, y = -log10(FDR))) + geom_point(aes(color = regulated), size = 1, alpha = 1) + scale_color_manual(values = c(&#39;up&#39; = &#39;#F07C79&#39;, &#39;down&#39; = &#39;#4588C8&#39;, &#39;normal&#39; = &#39;gray&#39;)) + geom_hline(yintercept = -log10(0.05), linetype = &quot;dashed&quot;, color = &quot;black&quot;, size = 0.5) + geom_vline(xintercept = c(-1, 1), linetype = &quot;dashed&quot;, color = &quot;black&quot;, size=1) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_text(size = 16, color = &quot;black&quot;, face = &quot;bold&quot;), axis.text = element_text(size = 16, color = &quot;black&quot;, face = &quot;bold&quot;), panel.border = element_rect(color = &quot;black&quot;, size = 1.5) ) # 计算图的范围 x_range &lt;- ggplot_build(p)$layout$panel_params[[1]]$x.range y_range &lt;- ggplot_build(p)$layout$panel_params[[1]]$y.range # 定义注释位置 x_left &lt;- x_range[1] + (x_range[2] - x_range[1]) * 0.05 x_right &lt;- x_range[2] - (x_range[2] - x_range[1]) * 0.05 y_top &lt;- y_range[2] - (y_range[2] - y_range[1]) * 0.05 # 添加注释 vol_p &lt;- p + annotate(&quot;text&quot;, x = x_right, y = y_top, label = paste0(up_count), size = 7, hjust = 1, color = &#39;#F07C79&#39;) + annotate(&quot;text&quot;, x = x_left, y = y_top, label = paste0(down_count), size = 7, hjust = 0, color = &#39;#4588C8&#39;) return(vol_p) } # 对列表中的每个数据框进行处理 vol_DESeq2 &lt;- setNames(lapply(cr_DESeq2, vol), names(cr_DESeq2)) vol_edgeR &lt;- setNames(lapply(cr_edgeR, vol), names(cr_edgeR)) # 创建图像保存目录 dir.create(&quot;DEG_Analysis/2_DEG_visualization/DESeq2&quot;, recursive = T) dir.create(&quot;DEG_Analysis/2_DEG_visualization/edgeR&quot;, recursive = T) for (i in names(vol_DESeq2)) { ggsave(paste0(&quot;DEG_Analysis/2_DEG_visualization/DESeq2/&quot;, i, &quot;_volcano_DESeq2.pdf&quot;), vol_DESeq2[[i]] ) } for (i in names(vol_edgeR)) { ggsave(paste0(&quot;DEG_Analysis/2_DEG_visualization/edgeR/&quot;, i, &quot;_volcano_edgeR.pdf&quot;), vol_edgeR[[i]] ) } 4.3.2 热图 # 加载必要的包 library(pheatmap) library(tidyverse) # 定义画图函数 phe &lt;- function(DEG_exp){ exp &lt;- DEG_exp %&gt;% filter(regulated == &quot;up&quot; | regulated == &quot;down&quot;) %&gt;% column_to_rownames(var = &quot;SYMBOL&quot;) %&gt;% select(any_of(group$sample)) phe_p &lt;- pheatmap(exp, show_colnames =T, show_rownames = F, scale = &quot;row&quot;, cluster_cols = T ) return(phe_p) } # 对列表中的每个数据框进行处理 phe_DESeq2 &lt;- setNames(lapply(cr_DESeq2, phe), names(cr_DESeq2)) phe_edgeR &lt;- setNames(lapply(cr_edgeR, phe), names(cr_edgeR)) # 创建图像保存目录 dir.create(&quot;DEG_Analysis/2_DEG_visualization/DESeq2&quot;, recursive = T) dir.create(&quot;DEG_Analysis/2_DEG_visualization/edgeR&quot;, recursive = T) for (i in names(phe_DESeq2)) { ggsave(paste0(&quot;DEG_Analysis/2_DEG_visualization/DESeq2/&quot;, i, &quot;_pheatmap_DESeq2.pdf&quot;), phe_DESeq2[[i]] ) } for (i in names(phe_edgeR)) { ggsave(paste0(&quot;DEG_Analysis/2_DEG_visualization/edgeR/&quot;, i, &quot;_pheatmap_edgeR.pdf&quot;), phe_edgeR[[i]] ) } "],["差异基因富集分析.html", "第 5 章 差异基因富集分析 5.1 GO 富集分析 5.2 KEGG 富集分析 5.3 GSEA 分析", " 第 5 章 差异基因富集分析 # 加载必要的包 library(tidyverse) library(clusterProfiler) library(org.Hs.eg.db) library(org.Mm.eg.db) if (species == &quot;human&quot;) { org_db &lt;- &quot;org.Hs.eg.db&quot; kegg_prefix &lt;- &quot;hsa&quot; } else if (species == &quot;mouse&quot;) { org_db &lt;- &quot;org.Mm.eg.db&quot; kegg_prefix &lt;- &quot;mmu&quot; } else { stop(&quot;Unsupported species. Please use &#39;human&#39; or &#39;mouse&#39;.&quot;) } 5.1 GO 富集分析 GO &lt;- function(DEG_exp){ geneList &lt;- DEG_exp$SYMBOL %&gt;% unique() exp &lt;- DEG_exp %&gt;% filter(regulated == &quot;up&quot; | regulated == &quot;down&quot;) gene &lt;- exp$SYMBOL %&gt;% unique() ego &lt;- enrichGO(gene = gene, universe = geneList, OrgDb = org_db, keyType = &#39;SYMBOL&#39;, ont = &quot;all&quot;, pAdjustMethod = &quot;BH&quot;, pvalueCutoff = 0.99, qvalueCutoff = 0.99, readable = TRUE) go_bar &lt;- barplot(ego, split=&quot;ONTOLOGY&quot;, font.size = 10) + facet_grid(ONTOLOGY~., scales=&quot;free&quot;) + scale_y_discrete(labels=function(x) str_wrap(x, width=50)) return(list(ego = ego, go_bar = go_bar)) } # 对列表中的每个数据框进行处理 GO_DESeq2 &lt;- setNames(lapply(cr_DESeq2, GO), names(cr_DESeq2)) GO_edgeR &lt;- setNames(lapply(cr_edgeR, GO), names(cr_edgeR)) # 创建文件保存目录 dir.create(&quot;DEG_Analysis/3_DEG_ORA/DESeq2&quot;, recursive = T) dir.create(&quot;DEG_Analysis/3_DEG_ORA/edgeR&quot;, recursive = T) for (i in names(GO_DESeq2)) { ggsave(paste0(&quot;DEG_Analysis/3_DEG_ORA/DESeq2/&quot;, i, &quot;_GO_DESeq2.pdf&quot;), GO_DESeq2[[i]]$go_bar ) write_csv(GO_DESeq2[[i]]$ego@result, paste0(&quot;DEG_Analysis/3_DEG_ORA/DESeq2/&quot;, i, &quot;_GO_DESeq2.csv&quot;)) } for (i in names(GO_edgeR)) { ggsave(paste0(&quot;DEG_Analysis/3_DEG_ORA/edgeR/&quot;, i, &quot;_GO_edgeR.pdf&quot;), GO_edgeR[[i]]$go_bar ) write_csv(GO_edgeR[[i]]$ego@result, paste0(&quot;DEG_Analysis/3_DEG_ORA/edgeR/&quot;, i, &quot;_GO_edgeR.csv&quot;)) } 5.2 KEGG 富集分析 KEGG &lt;- function(DEG_exp){ exp &lt;- DEG_exp %&gt;% filter(regulated == &quot;up&quot; | regulated == &quot;down&quot;) gene &lt;- exp$SYMBOL %&gt;% unique() gene_df &lt;- bitr(gene, fromType = &quot;SYMBOL&quot;, toType = c(&quot;ENTREZID&quot;), OrgDb = org_db) kk &lt;- enrichKEGG(gene = gene_df$ENTREZID, organism = kegg_prefix,, pvalueCutoff = 0.999, qvalueCutoff =0.999) kk &lt;- DOSE::setReadable(kk, OrgDb = org_db, keyType=&#39;ENTREZID&#39;) #按需替换 kegg_bar &lt;- barplot(kk, showCategory=20) return(list(kk = kk, kegg_bar = kegg_bar)) } # 对列表中的每个数据框进行处理 KEGG_DESeq2 &lt;- setNames(lapply(cr_DESeq2, KEGG), names(cr_DESeq2)) KEGG_edgeR &lt;- setNames(lapply(cr_edgeR, KEGG), names(cr_edgeR)) # 创建文件保存目录 dir.create(&quot;DEG_Analysis/3_DEG_ORA/DESeq2&quot;, recursive = T) dir.create(&quot;DEG_Analysis/3_DEG_ORA/edgeR&quot;, recursive = T) for (i in names(KEGG_DESeq2)) { ggsave(paste0(&quot;DEG_Analysis/3_DEG_ORA/DESeq2/&quot;, i, &quot;_KEGG_DESeq2.pdf&quot;), KEGG_DESeq2[[i]]$kegg_bar ) write_csv(KEGG_DESeq2[[i]]$kk@result, paste0(&quot;DEG_Analysis/3_DEG_ORA/DESeq2/&quot;, i, &quot;_KEGG_DESeq2.csv&quot;)) } for (i in names(KEGG_edgeR)) { ggsave(paste0(&quot;DEG_Analysis/3_DEG_ORA/edgeR/&quot;, i, &quot;_KEGG_edgeR.pdf&quot;), KEGG_edgeR[[i]]$kegg_bar ) write_csv(KEGG_edgeR[[i]]$kk@result, paste0(&quot;DEG_Analysis/3_DEG_ORA/edgeR/&quot;, i, &quot;_KEGG_edgeR.csv&quot;)) } 5.3 GSEA 分析 # 加载必要的包 library(tidyverse) library(clusterProfiler) library(org.Hs.eg.db) library(org.Mm.eg.db) # 确定物种 if (species == &quot;human&quot;) { org_db &lt;- &quot;org.Hs.eg.db&quot; kegg_prefix &lt;- &quot;hsa&quot; } else if (species == &quot;mouse&quot;) { org_db &lt;- &quot;org.Mm.eg.db&quot; kegg_prefix &lt;- &quot;mmu&quot; } else { stop(&quot;Unsupported species. Please use &#39;human&#39; or &#39;mouse&#39;.&quot;) } 5.3.1 KEGG数据库 # 定义GSEA函数 GSE_kk &lt;- function(DEG_exp) { gene_df &lt;- bitr(DEG_exp$SYMBOL, fromType = &quot;SYMBOL&quot;, toType = c(&quot;ENTREZID&quot;), OrgDb = org_db) %&gt;% distinct(SYMBOL, .keep_all = TRUE) DEG_exp &lt;- left_join(DEG_exp, gene_df, by = &quot;SYMBOL&quot;) %&gt;% na.omit() geneList &lt;- DEG_exp$log2FoldChange names(geneList) &lt;- DEG_exp$ENTREZID geneList &lt;- sort(geneList, decreasing = TRUE) gse_kk &lt;- gseKEGG(geneList = geneList, organism = kegg_prefix, minGSSize = 10, pvalueCutoff = 0.99, verbose = FALSE) gse_kk &lt;- DOSE::setReadable(gse_kk, OrgDb = org_db, keyType = &#39;ENTREZID&#39;) # 可视化 up_k &lt;- gse_kk[head(order(gse_kk$enrichmentScore, decreasing = TRUE)), ] up_k$group &lt;- 1 down_k &lt;- gse_kk[tail(order(gse_kk$enrichmentScore, decreasing = TRUE)), ] down_k$group &lt;- -1 dat &lt;- rbind(up_k, down_k) dat$pvalue &lt;- -log10(dat$pvalue) dat$pvalue &lt;- dat$pvalue * dat$group dat &lt;- dat[order(dat$pvalue, decreasing = FALSE), ] gse_p &lt;- ggplot(dat, aes(x = reorder(Description, order(pvalue, decreasing = FALSE)), y = pvalue, fill = group)) + geom_bar(stat = &quot;identity&quot;) + scale_fill_gradient(low = &quot;#34bfb5&quot;, high = &quot;#ff6633&quot;, guide = FALSE) + scale_x_discrete(name = &quot;Pathway names&quot;) + scale_y_continuous(name = &quot;log10P-value&quot;) + coord_flip() + ggstatsplot::theme_ggstatsplot() + theme(plot.title = element_text(size = 15, hjust = 0.5), axis.text = element_text(size = 12, face = &#39;bold&#39;), panel.grid = element_blank()) + ggtitle(&quot;Pathway Enrichment&quot;) return(list(gse_kk = gse_kk, gse_p = gse_p)) } # 对列表中的每个数据框进行处理 GSE_kk_DESeq2 &lt;- setNames(lapply(cr_DESeq2, GSE_kk), names(cr_DESeq2)) GSE_kk_edgeR &lt;- setNames(lapply(cr_edgeR, GSE_kk), names(cr_edgeR)) # 创建文件保存目录 dir.create(&quot;DEG_Analysis/4_GSEA/DESeq2&quot;, recursive = TRUE) dir.create(&quot;DEG_Analysis/4_GSEA/edgeR&quot;, recursive = TRUE) # 保存结果 for (i in names(GSE_kk_DESeq2)) { ggsave(paste0(&quot;DEG_Analysis/4_GSEA/DESeq2/&quot;, i, &quot;_GSE_kk_DESeq2.pdf&quot;), GSE_kk_DESeq2[[i]]$gse_p) write_csv(GSE_kk_DESeq2[[i]]$gse_kk@result, paste0(&quot;DEG_Analysis/4_GSEA/DESeq2/&quot;, i, &quot;_GSE_kk_DESeq2.csv&quot;)) } for (i in names(GSE_kk_edgeR)) { ggsave(paste0(&quot;DEG_Analysis/4_GSEA/edgeR/&quot;, i, &quot;_GSE_kk_edgeR.pdf&quot;), GSE_kk_edgeR[[i]]$gse_p) write_csv(GSE_kk_edgeR[[i]]$gse_kk@result, paste0(&quot;DEG_Analysis/4_GSEA/edgeR/&quot;, i, &quot;_GSE_kk_edgeR.csv&quot;)) } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
